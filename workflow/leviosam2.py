'''
Nae-Chyun Chen
Johns Hopkins University
2021-2022
'''

import argparse
import pathlib
import subprocess
import typing


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument('--leviosam2_binary',
                        default='leviosam2',
                        type=str,
                        help='Path to the leviosam2 executable')
    parser.add_argument('--samtools_binary',
                        default='samtools',
                        type=str,
                        help='Path to the samtools executable')
    parser.add_argument('bgzip_binary',
                        default='bgzip',
                        type=str,
                        help='Path to the bgzip executable')
    parser.add_argument('--gnu_time_binary',
                        default='gtime',
                        type=str,
                        help=('Path to the GNU Time executable '
                              '(see https://www.gnu.org/software/time/)'))
    parser.add_argument('--measure_time',
                        action='store_true',
                        help=('Activate to measure time with '
                              '`--gnu_time_binary`'))
    parser.add_argument('--keep_tmp_files',
                        action='store_true',
                        help=('Activate to keep temp files '
                              'generated by the workflow'))
    parser.add_argument('-t',
                        '--num_threads',
                        type=int,
                        default=4,
                        help='Number of threads to use')
    parser.add_argument('--sequence_type',
                        type=str,
                        required=True,
                        choices=['ilmn_pe', 'ilmn_se', 'pb_hifi', 'ont'],
                        help='Type of sequence data')
    parser.add_argument('-a',
                        '--aligner',
                        type=str,
                        required=True,
                        choices=[
                            'bowtie2', 'bwamem', 'bwamem2', 'minimap2',
                            'winnowmap2', 'strobealign'
                        ])
    parser.add_argument('--aligner_binary',
                        type=str,
                        default='auto',
                        help=('Path to the aligner executable. '
                              'If empty, inferred using `--aligner`'))
    parser.add_argument('--source_label',
                        type=str,
                        default='source',
                        help='Label of the source reference')
    parser.add_argument('--target_label',
                        type=str,
                        default='target',
                        help='Label of the target reference')
    parser.add_argument('--read_group', type=str, help='Read group string')
    parser.add_argument('-g',
                        '--lift_max_gap',
                        type=int,
                        help='[lift] Max chain gap size allowed')
    parser.add_argument('--lift_commit_min_mapq',
                        type=int,
                        help='[lift] Min MAPQ to commit')
    parser.add_argument('--lift_commit_min_score',
                        type=int,
                        help='[lift] Min alignment score (AS:i tag) to commit')
    parser.add_argument('--lift_commit_max_frac_clipped',
                        type=float,
                        help='[lift] Min fraction of clipped bases to commit')
    parser.add_argument('--lift_commit_max_isize',
                        type=int,
                        help='[lift] Max template length (isize) to commit')
    parser.add_argument('--lift_commit_max_hdist',
                        type=int,
                        help='[lift] Max edit distance (NM:i tag) to commit')
    parser.add_argument('--lift_bed_commit_source',
                        type=str,
                        help=('[lift] Path to a BED (source coordinates) '
                              'where reads in the regions are always '
                              'committed (often for suppress annotations)'))
    parser.add_argument('--lift_bed_defer_target',
                        type=str,
                        help=('[lift] Path to a BED (target cooridnates'
                              'where reads in the regions are always '
                              'deferred'))
    parser.add_argument('--lift_realign_config',
                        type=str,
                        help=('[lift] Path to the config file for '
                              'realignment'))
    parser.add_argument('-i',
                        '--input_alignment',
                        type=str,
                        required=True,
                        help='Path to the input SAM/BAM/CRAM file')
    parser.add_argument('-o',
                        '--out_prefix',
                        type=str,
                        required=True,
                        help='Output prefix')
    parser.add_argument('-C',
                        '--leviosam2_index',
                        type=str,
                        required=True,
                        help='Path to the leviosam2 index')
    parser.add_argument('-f',
                        '--target_fasta',
                        type=str,
                        required=True,
                        help='Path to the target reference (FASTA file)')
    parser.add_argument('-fi',
                        '--target_fasta_index',
                        type=str,
                        help=('Path to the target reference index '
                              'for `--aligner`'))
    parser.add_argument('-s',
                        '--source_fasta',
                        type=str,
                        required=True,
                        help='Path to the source reference (FASTA file)')
    parser.add_argument('-si',
                        '--source_fasta_index',
                        type=str,
                        help=('Path to the source reference index '
                              'for `--aligner`'))
    parser.add_argument('--dryrun',
                        action='store_true',
                        help='Activate the dryrun mode')
    parser.add_argument('--forcerun',
                        action='store_true',
                        help='Activate the forcerun mode. Rerun everything')
    # parser.add_argument()
    # parser.add_argument()
    # parser.add_argument()
    # parser.add_argument()
    # parser.add_argument()

    args = parser.parse_args()
    return args


def check_input_exists(fn_in: pathlib.Path) -> None:
    if not fn_in.is_file():
        raise FileNotFoundError(f'{fn_in} is not a file')


def validate_binary(cmd: str, lenient: bool = False) -> None:
    '''Validate if an executable is valid.
    
    Args:
        - cmd: command to run
        - lenient: lenient mode.
            If False, return True a returncode of 0. If True, return True when
            either stdout/stderr has >1 lines of output.
            When a command does not exist, we get a "command not found" stderr
            result, so we require >1 lines of output.

    Returns:
        - bool: True if a binary is valid
    '''
    subprocess_out = subprocess.run([cmd], shell=True, capture=True)
    if not lenient and subprocess_out.returncode != 0:
        raise ValueError(f'{cmd} has a non-zero return code '
                         f'{subprocess_out.returncode}')
    else:

        def _count_lines(bin_text):
            return bin_text.decode('utf-8').count('\n')

        if not (_count_lines(subprocess_out.stdout) > 1
                or _count_lines(subprocess_out.stderr) > 1):
            raise ValueError(f'{cmd} has an unexpected output.\n'
                             f'STDOUT = {subprocess_out.stdout}\n'
                             f'STDERR = {subprocess_out.stderr}')


def run_leviosam2(
    time_cmd: str,
    leviosam2: str,
    clft: str,
    fn_input: pathlib.Path,
    out_prefix: pathlib.Path,
    num_threads: int,
    lift_commit_min_mapq: typing.Union[int, None],
    lift_commit_min_score: typing.Union[int, None],
    lift_commit_max_frac_clipped: typing.Union[float, None],
    lift_commit_max_isize: typing.Union[int, None],
    lift_commit_max_hdist: typing.Union[int, None],
    lift_max_gap: typing.Union[int, None],
    lift_bed_commit_source: str,
    lift_bed_defer_target: str,
    lift_realign_config: str,
    target_fasta: pathlib.Path,
    dryrun: bool = False,
    forcerun: bool = False
) -> typing.Union[str, 'subprocess.CompletedProcess[bytes]']:
    '''Run leviosam2.
    '''
    lift_commit_min_mapq_arg = f'-S mapq:{lift_commit_min_mapq}' \
        if lift_commit_min_mapq else ''
    lift_commit_min_score_arg = f'-S aln_score:{lift_commit_min_score}' \
        if lift_commit_min_score else ''
    lift_commit_max_frac_clipped_arg = \
        f'-S clipped_frac:{lift_commit_max_frac_clipped}' \
            if lift_commit_max_frac_clipped else ''
    lift_commit_max_isize_arg = f'-S isize:{lift_commit_max_isize}' \
        if lift_commit_max_isize else ''
    lift_commit_max_hdist_arg = f'-S hdist:{lift_commit_max_hdist}' \
        if lift_commit_max_hdist else ''
    lift_max_gap_arg = f'-G {lift_max_gap}' if lift_max_gap else ''
    lift_bed_commit_source_arg = f'-r {lift_bed_commit_source}' \
        if lift_bed_commit_source else ''
    lift_bed_defer_target_arg = f'-D {lift_bed_defer_target}' \
        if lift_bed_defer_target else ''
    lift_realign_config_arg = f'-x {lift_realign_config}' \
        if lift_realign_config else ''

    fn_out_committed = (out_prefix.parent / f'{out_prefix.name}-committed.bam')

    cmd = (f'{time_cmd} {leviosam2} lift -C {clft} '
           f'-a {fn_input} -p {out_prefix} '
           f'-t {num_threads} -m -f {target_fasta} '
           f'{lift_commit_min_mapq_arg} '
           f'{lift_commit_min_score_arg} '
           f'{lift_commit_max_frac_clipped_arg} '
           f'{lift_commit_max_hdist_arg} '
           f'{lift_commit_max_isize_arg} '
           f'{lift_max_gap_arg} '
           f'{lift_bed_commit_source_arg} '
           f'{lift_bed_defer_target_arg} '
           f'{lift_realign_config_arg}')
    if dryrun:
        return cmd
    else:
        check_input_exists(fn_input)
        if (not forcerun) and fn_out_committed.is_file():
            print('[Info] Skip run_leviosam2 -- '
                  f'{fn_out_committed} exists')
            return 'skip'
        return subprocess.run([cmd], shell=True)


def run_sort_committed(
    time_cmd: str,
    samtools: str,
    num_threads: int,
    out_prefix: str,
    dryrun: bool = False,
    forcerun: bool = False
) -> typing.Union[str, 'subprocess.CompletedProcess[bytes]']:
    '''Sort the committed BAM.
    
    Subprocess inputs:
        - <out_prefix>-committed.bam
    Subprocess outputs:
        - <out_prefix>-committed-sorted.bam
    '''
    fn_in_bam = (out_prefix.parent / f'{out_prefix.name}-committed.bam')
    fn_out = (out_prefix.parent / f'{out_prefix.name}-committed-sorted.bam')

    cmd = (f'{time_cmd} {samtools} sort -@ {num_threads} '
           f'-o {fn_out} {fn_in_bam}')
    if dryrun:
        return cmd
    else:
        check_input_exists(fn_in_bam)
        if (not forcerun) and fn_out.is_file():
            print('[Info] Skip run_sort_committed -- '
                  f'{fn_out} exists')
            return 'skip'
        return subprocess.run([cmd], shell=True)


def run_collate_pe(
    time_cmd: str,
    leviosam2: str,
    out_prefix: pathlib.Path,
    dryrun: bool = False,
    forcerun: bool = False
) -> typing.Union[str, 'subprocess.CompletedProcess[bytes]']:
    '''[Paired-end] Collate committed/deferred BAMs to properly paired FASTQs.

    Subprocess inputs:
        - <out_prefix>-committed-sorted.bam
        - <out_prefix>-deferred.bam
    Subprocess outputs:
        - <out_prefix>-paired-deferred-R1.fq.gz
        - <out_prefix>-paired-deferred-R2.fq.gz
    '''
    fn_in_committed = (out_prefix.parent /
                       f'{out_prefix.name}-committed-sorted.bam')
    fn_in_deferred = (out_prefix.parent / f'{out_prefix.name}-deferred.bam')
    out_prefix = (out_prefix.parent / f'{out_prefix.name}-paired')
    fn_out_fq1 = (out_prefix.parent / f'{out_prefix.name}-deferred-R1.fq.gz')
    fn_out_fq2 = (out_prefix.parent / f'{out_prefix.name}-deferred-R2.fq.gz')

    cmd = (f'{time_cmd} {leviosam2} collate '
           f'-a {fn_in_committed} -b {fn_in_deferred} -p {out_prefix}')
    if dryrun:
        return cmd
    else:
        check_input_exists(fn_in_committed)
        check_input_exists(fn_in_deferred)

        if (not forcerun) and fn_out_fq1.is_file() and fn_out_fq2.is_file():
            print('[Info] Skip run_collate_pe -- '
                  f'both {fn_out_fq1} and {fn_out_fq2} exist')
            return 'skip'
        return subprocess.run([cmd], shell=True)


def run_realign_deferred(
    time_cmd: str,
    aligner: str,
    aligner_binary: str,
    is_single_end: bool,
    samtools: str,
    out_prefix: pathlib.Path,
    target_fasta_index: str,
    num_threads: int,
    rg_string: str,
    target_fasta: pathlib.Path,
    sequence_type: str,
    dryrun: bool = False,
    forcerun: bool = False
) -> typing.Union[str, 'subprocess.CompletedProcess[bytes]']:
    '''Re-align deferred reads.

    Aligned reads are piped to `samtools sort` for single-end reads.
    Paired-end reads need to be collated later so just compressed.
    Thread resource allocation:
        - paired-end: alignment=`num_threads`-1, view=1
        - single-end: alignment=`num_threads`-sort, sort=`num_threads//5`
    '''

    if not is_single_end:
        num_threads_aln = max(1, num_threads - 1)
        if aligner not in ['bowtie2', 'bwamem', 'bwamem2', 'strobealign']:
            raise ValueError('We have not supported paired-end '
                             f'mode for aligner {aligner}')
        fn_in_fq1 = (out_prefix.parent /
                     f'{out_prefix.name}-paired-deferred-R1.fq.gz')
        fn_in_fq2 = (out_prefix.parent /
                     f'{out_prefix.name}-paired-deferred-R2.fq.gz')
        fn_out = (out_prefix.parent /
                  f'{out_prefix.name}-paired-realigned.bam')
        cmd_samtools = f'{time_cmd} {samtools} view -hbo {fn_out}'
    else:
        num_threads_sort = max(1, num_threads // 5)
        num_threads_aln = max(1, num_threads - num_threads_sort)
        fn_in_fq = (out_prefix.parent / f'{out_prefix.name}-deferred.fq.gz')
        fn_out = (out_prefix.parent / f'{out_prefix.name}-realigned.bam')
        cmd_samtools = (f'{time_cmd} {samtools} sort -@ {num_threads_aln} '
                        f'-o {fn_out}')

    if aligner == 'bowtie2':
        if not is_single_end:
            reads = '-1 {fn_in_fq1} -2 {fn_in_fq2}'
        else:
            reads = '-U {fn_in_fq}'
        cmd = (f'{time_cmd} {aligner_binary} {rg_string} -p {num_threads_aln} '
               f'-x {target_fasta_index} {reads} | '
               f'{cmd_samtools}')
    elif aligner in ['bwamem', 'bwamem2']:
        if rg_string != '':
            rg_string = f'-R {rg_string}'
        if not is_single_end:
            reads = '{fn_in_fq1} {fn_in_fq2}'
        else:
            reads = '{fn_in_fq}'
        cmd = (f'{time_cmd} {aligner_binary} mem {rg_string} '
               f'-t {num_threads_aln} {target_fasta_index} {reads} | '
               f'{cmd_samtools}')
    elif aligner == 'strobealign':
        if rg_string != '':
            rg_string = f'--rg {rg_string}'
        if not is_single_end:
            reads = '{fn_in_fq1} {fn_in_fq2}'
        else:
            reads = '{fn_in_fq}'
        cmd = (f'{time_cmd} {aligner_binary} {rg_string} -t {num_threads_aln} '
               f'{target_fasta} {reads} | '
               f'{cmd_samtools}')
    elif aligner in ['minimap2', 'winnowmap2']:
        # Do not use a prefix other than 'map-hifi' and 'map-ont' modes.
        preset = ''
        if sequence_type == 'pb-hifi':
            preset = '-x map-hifi'
        elif sequence_type == 'ont':
            preset = '-x map-ont'
        if rg_string != '':
            rg_string = f'-R {rg_string}'
        if not is_single_end:
            reads = '{fn_in_fq1} {fn_in_fq2}'
        else:
            reads = '{fn_in_fq}'
        cmd = (f'{time_cmd} {aligner_binary} {rg_string} -a {preset} --MD '
               f'-t {num_threads_aln} {target_fasta} {reads} | '
               f'{cmd_samtools}')

    if dryrun:
        return cmd
    else:
        check_input_exists(fn_in_fq1)
        check_input_exists(fn_in_fq2)

        if (not forcerun) and fn_out.is_file():
            print(f'[Info] Skip run_realign_deferred -- {fn_out} exists')
            return 'skip'
        return subprocess.run([cmd], shell=True)


def run_refflow_merge_pe(
    time_cmd: str,
    samtools: str,
    leviosam2: str,
    out_prefix: pathlib.Path,
    source_label: str,
    target_label: str,
    num_threads: int,
    dryrun: bool = False,
    forcerun: bool = False
) -> typing.Union[str, 'subprocess.CompletedProcess[bytes]']:
    '''(Paired-end) reference flow-style merging of deferred/realigned BAMs.
    '''
    fn_in_realigned = (out_prefix.parent /
                       f'{out_prefix.name}-paired-realigned.bam')
    fn_in_deferred = (out_prefix.parent /
                      f'{out_prefix.name}-paired-deferred.bam')
    fn_realigned_sort_n = (out_prefix.parent /
                           f'{out_prefix.name}--paired-realigned-sorted_n.bam')
    fn_deferred_sort_n = (out_prefix.parent /
                          f'{out_prefix.name}--paired-deferred-sorted_n.bam')
    fn_out = (out_prefix.parent /
              f'{out_prefix.name}-paired-deferred-reconciled-sorted.bam')
    cmd = ''
    cmd += (f'{time_cmd} {samtools} sort -@ {num_threads} -n '
            f'-o {fn_realigned_sort_n} {fn_in_realigned} && ')
    cmd += (f'{time_cmd} {samtools} sort -@ {num_threads} -n '
            f'-o {fn_deferred_sort_n} {fn_in_deferred} && ')
    cmd += (f'{time_cmd} {leviosam2} reconcile '
            f'-s {source_label}:{fn_deferred_sort_n} '
            f'-s {target_label}:{fn_realigned_sort_n} '
            f'-m -o - | '
            f'{time_cmd} {samtools} sort -@ {num_threads} -o {fn_out}')

    if dryrun:
        return cmd
    else:
        check_input_exists(fn_in_realigned)
        check_input_exists(fn_in_deferred)

        if (not forcerun) and fn_out.is_file():
            print(f'[Info] Skip run_refflow_merge_pe -- {fn_out} exists')
            return 'skip'
        return subprocess.run([cmd], shell=True)


def run_merge_and_index(
    time_cmd: str,
    samtools: str,
    out_prefix: pathlib.Path,
    is_single_end: bool,
    num_threads: int,
    dryrun: bool = False,
    forcerun: bool = False
) -> typing.Union[str, 'subprocess.CompletedProcess[bytes]']:
    '''Merge all processed BAMs and index.
    '''
    fn_in_committed = (out_prefix.parent /
                       f'{out_prefix.name}-committed-sorted.bam ')
    if not is_single_end:
        fn_in_deferred = (
            out_prefix.parent /
            f'{out_prefix.name}-paired-deferred-reconciled-sorted.bam')
    else:
        fn_in_deferred = (out_prefix.parent /
                          f'{out_prefix.name}-realigned.bam')
    fn_out = (out_prefix.parent / f'{out_prefix.name}-final.bam')

    cmd = ''
    cmd += (f'{time_cmd} {samtools} merge -@ {num_threads} --write-index '
            f'-o {fn_out} {fn_in_committed} {fn_in_deferred} && ')
    cmd += (f'{time_cmd} {samtools} index {fn_out}')

    if dryrun:
        return cmd
    else:
        check_input_exists(fn_in_committed)
        check_input_exists(fn_in_deferred)

        if (not forcerun) and fn_out.is_file():
            print(f'[Info] Skip run_merge_and_index -- {fn_out} exists')
            return 'skip'
        return subprocess.run([cmd], shell=True)


def run_bam_to_fastq_se(
    time_cmd: str,
    samtools: str,
    bgzip: str,
    out_prefix: pathlib.Path,
    dryrun: bool = False,
    forcerun: bool = False
) -> typing.Union[str, 'subprocess.CompletedProcess[bytes]']:
    '''(Single-end) Convert deferred BAM to FASTQ.
    '''
    fn_in_bam = (out_prefix.parent / f'{out_prefix.name}-deferred.bam')
    fn_out = (out_prefix.parent / f'{out_prefix.name}-deferred.fq.gz')
    cmd = (f'{time_cmd} {samtools} fastq index {fn_in_bam} | '
           f'{time_cmd} {bgzip} > {fn_out}')

    if dryrun:
        return cmd
    else:
        check_input_exists(fn_in_bam)

        if (not forcerun) and fn_out.is_file():
            print(f'[Info] Skip run_bam_to_fastq_se -- {fn_out} exists')
            return 'skip'
        return subprocess.run([cmd], shell=True)


def run_workflow(args: argparse.Namespace):
    if args.aligner_binary == 'auto':
        if args.aligner in [
                'bowtie2', 'minimap2', 'winnowmap2', 'strobealign'
        ]:
            aligner_binary = args.aligner
        elif args.aligner == 'bwamem':
            aligner_binary = 'bwa'
        elif args.aligner == 'bwamem2':
            aligner_binary = 'bwa-mem2'
        else:
            raise ValueError(f'Unsupported aligner: {args.aligner}')

    is_single_end = (args.sequence_type not in ['ilmn_pe'])

    # Check if executables are valid
    validate_binary(cmd='{args.samtools_binary} --version')
    validate_binary(cmd='{args.bgzip_binary} --version')
    validate_binary(cmd='{args.measure_time} --version')
    validate_binary(cmd='{args.leviosam2_binary}', lenient=True)
    validate_binary(cmd='{args.aligner_binary}', lenient=True)

    time_cmd = ''
    if args.measure_time:
        time_cmd = f'{args.gnu_time_binary} -v -ao {args.out_prefix}.time_log'

    # Pathify
    path_out_prefix = pathlib.Path(args.out_prefix)
    fn_target_fasta = pathlib.Path(args.target_fasta)
    check_input_exists(fn_target_fasta)
    fn_input_alignment = pathlib.Path(args.input_alignment)
    check_input_exists(fn_input_alignment)

    run_leviosam2(
        time_cmd=time_cmd,
        leviosam2=args.leviosam2_binary,
        clft=args.leviosam2_index,
        fn_input=fn_input_alignment,
        out_prefix=path_out_prefix,
        num_threads=args.num_threads,
        lift_commit_min_mapq=args.lift_commit_min_mapq,
        lift_commit_min_score=args.lift_commit_min_score,
        lift_commit_max_frac_clipped=args.lift_commit_max_frac_clipped,
        lift_commit_max_isize=args.lift_commit_max_isize,
        lift_commit_max_hdist=args.lift_commit_max_hdist,
        lift_max_gap=args.lift_max_gap,
        lift_bed_commit_source=args.lift_bed_commit_source,
        lift_bed_defer_target=args.lift_bed_defer_target,
        lift_realign_config=args.lift_realign_config,
        target_fasta=fn_target_fasta,
        dryrun=args.dryrun)

    run_sort_committed(time_cmd=time_cmd,
                       samtools=args.samtools_binary,
                       num_threads=args.num_threads,
                       out_prefix=path_out_prefix,
                       dryrun=args.dryrun,
                       forcerun=args.forcerun)

    if not is_single_end:
        run_collate_pe(time_cmd=time_cmd,
                       leviosam2=args.leviosam2_binary,
                       out_prefix=path_out_prefix,
                       dryrun=args.dryrun,
                       forcerun=args.forcerun)
        run_realign_deferred(time_cmd=time_cmd,
                             aligner=args.aligner,
                             aligner_binary=aligner_binary,
                             is_single_end=is_single_end,
                             out_prefix=path_out_prefix,
                             target_fasta=fn_target_fasta,
                             sequence_type=args.sequence_type,
                             dryrun=args.dryrun,
                             forcerun=args.forcerun)
        run_refflow_merge_pe(time_cmd=time_cmd,
                             samtools=args.samtools_binary,
                             leviosam2=args.leviosam2_binary,
                             out_prefix=path_out_prefix,
                             source_label=args.source_label,
                             target_label=args.target_label,
                             num_threads=args.num_threads,
                             dryrun=args.dryrun,
                             forcerun=args.forcerun)
    else:
        run_bam_to_fastq_se(time_cmd=time_cmd,
                            samtools=args.samtools_binary,
                            bgzip=args.bgzip_binary,
                            out_prefix=path_out_prefix,
                            dryrun=args.dryrun,
                            forcerun=args.forcerun)

        run_realign_deferred(time_cmd=time_cmd,
                             aligner=args.aligner,
                             aligner_binary=aligner_binary,
                             is_single_end=is_single_end,
                             out_prefix=path_out_prefix,
                             target_fasta=fn_target_fasta,
                             sequence_type=args.sequence_type,
                             dryrun=args.dryrun,
                             forcerun=args.forcerun)

    run_merge_and_index(time_cmd=time_cmd,
                        samtools=args.samtools_binary,
                        out_prefix=path_out_prefix,
                        is_single_end=is_single_end,
                        num_threads=args.num_threads,
                        dryrun=args.dryrun,
                        forcerun=args.forcerun)
    # run_clean()


if __name__ == '__main__':
    args = parse_args()
    run_workflow(args)
