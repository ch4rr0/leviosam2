'''
Nae-Chyun Chen
Johns Hopkins University
2021-2022
'''

import argparse
import pathlib
import subprocess
import typing


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument('--leviosam2_binary',
                        default='leviosam2',
                        type=str,
                        help='Path to the leviosam2 executable')
    parser.add_argument('--samtools_binary',
                        default='samtools',
                        type=str,
                        help='Path to the samtools executable')
    parser.add_argument('--gnu_time_binary',
                        default='gtime',
                        type=str,
                        help=('Path to the GNU Time executable '
                              '(see https://www.gnu.org/software/time/)'))
    parser.add_argument('--measure_time',
                        action='store_true',
                        help=('Activate to measure time with '
                              '`--gnu_time_binary`'))
    parser.add_argument('--keep_tmp_files',
                        action='store_true',
                        help=('Activate to keep temp files '
                              'generated by the workflow'))
    parser.add_argument('-t',
                        '--num_threads',
                        type=int,
                        default=8,
                        help='Number of threads to use')
    parser.add_argument('--sequence_type',
                        type=str,
                        required=True,
                        choices=['ilmn_pe', 'ilmn_se', 'pb_hifi', 'ont'],
                        help='Type of sequence data')
    parser.add_argument('-a',
                        '--aligner',
                        type=str,
                        required=True,
                        choices=[
                            'bowtie2', 'bwamem', 'bwamem2', 'minimap2',
                            'winnowmap2', 'strobealign'
                        ])
    parser.add_argument('--aligner_binary',
                        type=str,
                        default='auto',
                        help=('Path to the aligner executable. '
                              'If empty, inferred using `--aligner`'))
    parser.add_argument('--source_label',
                        type=str,
                        default='source',
                        help='Label of the source reference')
    parser.add_argument('--target_label',
                        type=str,
                        default='target',
                        help='Label of the target reference')
    parser.add_argument('--read_group', type=str, help='Read group string')
    parser.add_argument('-g',
                        '--lift_max_gap',
                        type=int,
                        help='[lift] Max chain gap size allowed')
    parser.add_argument('--lift_commit_min_mapq',
                        type=int,
                        help='[lift] Min MAPQ to commit')
    parser.add_argument('--lift_commit_min_score',
                        type=int,
                        help='[lift] Min alignment score (AS:i tag) to commit')
    parser.add_argument('--lift_commit_max_frac_clipped',
                        type=float,
                        help='[lift] Min fraction of clipped bases to commit')
    parser.add_argument('--lift_commit_max_isize',
                        type=int,
                        help='[lift] Max template length (isize) to commit')
    parser.add_argument('--lift_commit_max_hdist',
                        type=int,
                        help='[lift] Max edit distance (NM:i tag) to commit')
    parser.add_argument('--lift_bed_commit_source',
                        type=str,
                        help=('[lift] Path to a BED (source coordinates) '
                              'where reads in the regions are always '
                              'committed (often for suppress annotations)'))
    parser.add_argument('--lift_bed_defer_target',
                        type=str,
                        help=('[lift] Path to a BED (target cooridnates'
                              'where reads in the regions are always '
                              'deferred'))
    parser.add_argument('--lift_realign_config',
                        type=str,
                        help=('[lift] Path to the config file for '
                              'realignment'))
    parser.add_argument('-i',
                        '--input_alignment',
                        type=str,
                        required=True,
                        help='Path to the input SAM/BAM/CRAM file')
    parser.add_argument('-o',
                        '--out_prefix',
                        type=str,
                        required=True,
                        help='Output prefix')
    parser.add_argument('-C',
                        '--leviosam2_index',
                        type=str,
                        required=True,
                        help='Path to the leviosam2 index')
    parser.add_argument('-f',
                        '--target_fasta',
                        type=str,
                        required=True,
                        help='Path to the target reference (FASTA file)')
    parser.add_argument('-fi',
                        '--target_fasta_index',
                        type=str,
                        help=('Path to the target reference index '
                              'for `--aligner`'))
    parser.add_argument('-s',
                        '--source_fasta',
                        type=str,
                        required=True,
                        help='Path to the source reference (FASTA file)')
    parser.add_argument('-si',
                        '--source_fasta_index',
                        type=str,
                        help=('Path to the source reference index '
                              'for `--aligner`'))
    parser.add_argument('--dryrun',
                        action='store_true',
                        help='Activate the dryrun mode')
    parser.add_argument('--forcerun',
                        action='store_true',
                        help='Activate the forcerun mode. Rerun everything')
    # parser.add_argument()
    # parser.add_argument()
    # parser.add_argument()
    # parser.add_argument()
    # parser.add_argument()

    args = parser.parse_args()
    return args


def run_leviosam2(time_cmd: str, leviosam2: str, clft: str, fn_input: str,
                  out_prefix: str, num_threads: int,
                  lift_commit_min_mapq: typing.Union[int, None],
                  lift_commit_min_score: typing.Union[int, None],
                  lift_commit_max_frac_clipped: typing.Union[float, None],
                  lift_commit_max_isize: typing.Union[int, None],
                  lift_commit_max_hdist: typing.Union[int, None],
                  lift_max_gap: typing.Union[int, None],
                  lift_bed_commit_source: str, lift_bed_defer_target: str,
                  lift_realign_config: str, target_fasta: str, dryrun: bool
                  ) -> typing.Union[str, 'subprocess.CompletedProcess[bytes]']:
    '''Run leviosam2.

    if [ ! -s ${PFX}-committed.bam ]; then
        ${MT} ${LEVIOSAM} lift -C ${CLFT} -a ${INPUT} -t ${THR} -p ${PFX} -O bam \
        ${MAPQ} ${ISIZE} ${ALN_SCORE} ${FRAC_CLIPPED} ${HDIST} ${BED_ISEC_TH} \
        -G ${ALLOWED_GAPS} \
        ${REALN_CONFIG} \
        -m -f ${REF} ${DEFER_DEST_BED} ${COMMIT_SOURCE_BED}
    fi
    '''
    lift_commit_min_mapq_arg = f'-S mapq:{lift_commit_min_mapq} ' \
        if lift_commit_min_mapq else ''
    lift_commit_min_score_arg = f'-S aln_score:{lift_commit_min_score} ' \
        if lift_commit_min_score else ''
    lift_commit_max_frac_clipped_arg = \
        f'-S clipped_frac:{lift_commit_max_frac_clipped} ' \
            if lift_commit_max_frac_clipped else ''
    lift_commit_max_isize_arg = f'-S isize:{lift_commit_max_isize} ' \
        if lift_commit_max_isize else ''
    lift_commit_max_hdist_arg = f'-S hdist:{lift_commit_max_hdist} ' \
        if lift_commit_max_hdist else ''
    lift_max_gap_arg = f'-G {lift_max_gap} ' if lift_max_gap else ''
    lift_bed_commit_source_arg = f'-r {lift_bed_commit_source} ' \
        if lift_bed_commit_source else ''
    lift_bed_defer_target_arg = f'-D {lift_bed_defer_target} ' \
        if lift_bed_defer_target else ''
    lift_realign_config_arg = f'-x {lift_realign_config} ' \
        if lift_realign_config else ''

    cmd = (f'{time_cmd} {leviosam2} lift -C {clft} '
           f'-a {fn_input} -p {out_prefix}'
           f'-t {num_threads} -m -f {target_fasta} '
           f'{lift_commit_min_mapq_arg}'
           f'{lift_commit_min_score_arg}'
           f'{lift_commit_max_frac_clipped_arg}'
           f'{lift_commit_max_hdist_arg}'
           f'{lift_commit_max_isize_arg}'
           f'{lift_max_gap_arg}'
           f'{lift_bed_commit_source_arg}'
           f'{lift_bed_defer_target_arg}'
           f'{lift_realign_config_arg}')
    if dryrun:
        return cmd
    else:
        return subprocess.run([cmd], shell=True)


def run_sort_committed(
    time_cmd: str,
    samtools: str,
    num_threads: int,
    out_prefix: str,
    dryrun: bool = False,
    forcerun: bool = False
) -> typing.Union[str, 'subprocess.CompletedProcess[bytes]']:
    '''Sort the committed BAM.
    
    Subprocess inputs:
        - <out_prefix>-committed.bam
    Subprocess outputs:
        - <out_prefix>-committed-sorted.bam
    '''
    fn_in_bam = pathlib.Path(f'{out_prefix}-committed.bam')
    fn_out = pathlib.Path(f'{out_prefix}-committed-sorted.bam')

    cmd = (f'{time_cmd} {samtools} sort -@ {num_threads} '
           f'-o {fn_out} {fn_in_bam}')
    if dryrun:
        return cmd
    else:
        if not fn_in_bam.is_file():
            raise FileNotFoundError(f'{fn_in_bam} is not a file')
        if (not forcerun) and fn_out.is_file():
            print('[Info] Skip sort_committed -- '
                  f'{fn_out} exists')
            return 'skip'
        return subprocess.run([cmd], shell=True)


def run_collate_pe(
    time_cmd: str,
    leviosam2: str,
    out_prefix: str,
    dryrun: bool = False,
    forcerun: bool = False
) -> typing.Union[str, 'subprocess.CompletedProcess[bytes]']:
    '''[Paired-end] Collate committed/deferred BAMs to properly paired FASTQs.

    Subprocess inputs:
        - <out_prefix>-committed-sorted.bam
        - <out_prefix>-deferred.bam
    Subprocess outputs:
        - <out_prefix>-paired-deferred-R1.fq.gz
        - <out_prefix>-paired-deferred-R2.fq.gz
    '''
    fn_in_committed = pathlib.Path(f'{out_prefix}-committed-sorted.bam')
    fn_in_deferred = pathlib.Path(f'{out_prefix}-deferred.bam')
    out_prefix = pathlib.Path(f'{out_prefix}-paired')
    fn_out_fq1 = out_prefix.parent / \
        f'{out_prefix.name}-deferred-R1.fq.gz'
    fn_out_fq2 = out_prefix.parent / \
        f'{out_prefix.name}-deferred-R2.fq.gz'

    cmd = (f'{time_cmd} {leviosam2} collate '
           f'-a {fn_in_committed} -b {fn_in_deferred} -p {out_prefix}')
    if dryrun:
        return cmd
    else:
        if not fn_in_committed.is_file():
            raise FileNotFoundError(f'{fn_in_committed} is not a file')
        if not fn_in_deferred.is_file():
            raise FileNotFoundError(f'{fn_in_deferred} is not a file')

        if (not forcerun) and fn_out_fq1.is_file() and fn_out_fq2.is_file():
            print('[Info] Skip collate -- '
                  f'both {fn_out_fq1} and {fn_out_fq2} exist')
            return 'skip'
        return subprocess.run([cmd], shell=True)


def run_realign_deferred_pe(
    time_cmd: str,
    aligner: str,
    aligner_binary: str,
    target_fasta_index: str,
    rg_string: str,
    num_threads: int,
    samtools: str,
    out_prefix: str,
    target_fasta: str = None,
    dryrun: bool = False,
    forcerun: bool = False
) -> typing.Union[str, 'subprocess.CompletedProcess[bytes]']:
    '''[Paired-end] Re-align deferred reads.
    '''
    if aligner not in ['bowtie2', 'bwamem', 'bwamem2', 'strobealign']:
        raise ValueError('We have not supported paired-end '
                         f'mode for aligner {aligner}')
    fn_in_fq1 = pathlib.Path(f'{out_prefix}-paired-deferred-R1.fq.gz')
    fn_in_fq2 = pathlib.Path(f'{out_prefix}-paired-deferred-R2.fq.gz')
    fn_out = pathlib.Path(f'{out_prefix}-paired-realigned.bam')
    if aligner == 'bowtie2':
        cmd = (f'{time_cmd} {aligner_binary} {rg_string} -p {num_threads} '
               f'-x {target_fasta_index} '
               f'-1 {fn_in_fq1} -2 {fn_in_fq2} | '
               f'{time_cmd} {samtools} view -hbo {fn_out}')
    elif aligner in ['bwamem', 'bwamem2']:
        if rg_string != '':
            rg_string = f'-R {rg_string}'
        cmd = (f'{time_cmd} {aligner_binary} mem {rg_string} -t {num_threads} '
               f'{target_fasta_index} {fn_in_fq1} {fn_in_fq2} | '
               f'{time_cmd} {samtools} view -hbo {fn_out}')
    elif aligner == 'strobealign':
        if rg_string != '':
            rg_string = f'--rg {rg_string}'
        cmd = (f'{time_cmd} {aligner_binary} {rg_string} -t {num_threads} '
               f'{target_fasta} {fn_in_fq1} {fn_in_fq2} | '
               f'{time_cmd} {samtools} view -hbo {fn_out}')

    if dryrun:
        return cmd
    else:
        if not fn_in_fq1.is_file():
            raise FileNotFoundError(f'{fn_in_fq1} is not a file')
        if not fn_in_fq2.is_file():
            raise FileNotFoundError(f'{fn_in_fq2} is not a file')

        if (not forcerun) and fn_out.is_file():
            print(f'[Info] Skip realign_deferred_pe -- {fn_out} exists')
            return 'skip'
        return subprocess.run([cmd], shell=True)


def run_refflow_merge_pe():
    '''
    if [ ! -s ${PFX}-paired-deferred-reconciled-sorted.bam ]; then
        ${MT} samtools sort -@ ${THR} -n \
            -o ${PFX}-paired-realigned-sorted_n.bam ${PFX}-paired-realigned.bam
        ${MT} samtools sort -@ ${THR} -n \
            -o ${PFX}-paired-deferred-sorted_n.bam ${PFX}-paired-deferred.bam
        ${MT} ${LEVIOSAM} reconcile \
            -s ${SOURCE_LABEL}:${PFX}-paired-deferred-sorted_n.bam \
            -s ${TARGET_LABEL}:${PFX}-paired-realigned-sorted_n.bam \
            -m -o - | ${MT} samtools sort -@ ${THR} \
                -o ${PFX}-paired-deferred-reconciled-sorted.bam
    fi
    '''
    pass


def run_merge_pe():
    '''
    # Merge, sort, and clean
    if [ ! -s ${PFX}-final.bam ]; then
        ${MT} samtools merge -@ ${THR} --write-index -o ${PFX}-final.bam \
            ${PFX}-committed-sorted.bam ${PFX}-paired-deferred-reconciled-sorted.bam
        ${MT} samtools index ${PFX}-final.bam
    fi
    '''
    pass


def run_workflow(args: argparse.Namespace):
    time_cmd = ''
    if args.measure_time:
        time_cmd = f'{args.gnu_time_binary} -v -ao {args.out_prefix}.time_log'

    if args.aligner_binary == 'auto':
        if args.aligner in [
                'bowtie2', 'minimap2', 'winnowmap2', 'strobealign'
        ]:
            aligner_binary = args.aligner
        elif args.aligner == 'bwamem':
            aligner_binary = 'bwa'
        elif args.aligner == 'bwamem2':
            aligner_binary = 'bwa-mem2'
        else:
            raise ValueError(f'Unsupported aligner: {args.aligner}')

    # TODO
    # validate_binary()

    run_leviosam2(
        time_cmd=time_cmd,
        leviosam2=args.leviosam2_binary,
        clft=args.leviosam2_index,
        fn_input=args.input_alignment,
        out_prefix=args.out_prefix,
        num_threads=args.num_threads,
        lift_commit_min_mapq=args.lift_commit_min_mapq,
        lift_commit_min_score=args.lift_commit_min_score,
        lift_commit_max_frac_clipped=args.lift_commit_max_frac_clipped,
        lift_commit_max_isize=args.lift_commit_max_isize,
        lift_commit_max_hdist=args.lift_commit_max_hdist,
        lift_max_gap=args.lift_max_gap,
        lift_bed_commit_source=args.lift_bed_commit_source,
        lift_bed_defer_target=args.lift_bed_defer_target,
        lift_realign_config=args.lift_realign_config,
        target_fasta=args.target_fasta,
        dryrun=args.dryrun)

    run_sort_committed(time_cmd=time_cmd,
                       samtools=args.samtools_binary,
                       num_threads=args.num_threads,
                       out_prefix=args.out_prefix,
                       dryrun=args.dryrun,
                       forcerun=args.forcerun)

    if args.sequence_type in ['ilmn_pe']:
        run_collate_pe(time_cmd=time_cmd,
                       leviosam2=args.leviosam2_binary,
                       out_prefix=args.out_prefix,
                       dryrun=args.dryrun,
                       forcerun=args.forcerun)
        run_realign_deferred_pe(time_cmd=time_cmd,
                                aligner=args.aligner,
                                aligner_binary=aligner_binary,
                                out_prefix=args.out_prefix,
                                dryrun=args.dryrun,
                                forcerun=args.forcerun)
        run_refflow_merge_pe()
        run_merge_pe()
    else:
        run_bam_to_fastq_se()
        run_realign_deferred_se()
        run_merge_se()

    run_index()
    run_clean()


def validate_binary():
    args.gnu_time_binary


if __name__ == '__main__':
    args = parse_args()
    run_workflow(args)
